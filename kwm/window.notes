/* ^^^^ application ^^^^^ */
/* Add the Role to the list of AllowedWindowRoles for Application
    Output:
        KWMTiling.AllowedWindowRoles[Application] is appended with Role
    TODO:
        Doesn't do anything with windows
        application.cpp ?
 */
void AllowRoleForApplication(std::string Application, std::string Role);
/* Move window to display and set focus */
void CaptureApplication(window_info *Window);
/* Check whether application PID is cached  */
bool IsApplicationInCache(int PID, std::vector<AXUIElementRef> *Elements);
/* Check whether application has a role */
bool IsAppSpecificWindowRole(window_info *Window, CFTypeRef Role, CFTypeRef SubRole);
bool IsApplicationCapturedByScreen(window_info *Window);
bool IsApplicationFloating(window_info *Window);

/* vvvvv window (high-level)  vvvvv */
std::string GetWindowTitle(AXUIElementRef WindowRef);
CGSize GetWindowSize(AXUIElementRef WindowRef);
CGPoint GetWindowPos(AXUIElementRef WindowRef);
window_info *GetWindowByID(int WindowID);
CGPoint GetCursorPos();
bool IsFocusedWindowFloating();
bool IsWindowFloating(int WindowID, int *Index);
bool IsAnyWindowBelowCursor(); // TODO use the IsWindowBelowCursor function
bool IsWindowBelowCursor(window_info *Window); // TODO take cursor arg?
bool IsWindowOnActiveSpace(int WindowID);
void ClearFocusedWindow();
bool ShouldWindowGainFocus(window_info *Window);
bool GetWindowFocusedByOSX(int *WindowWID);
int GetFocusedWindowID();
bool FocusWindowOfOSX();
void FocusWindowBelowCursor();
std::vector<window_info> FilterWindowListAllDisplays();
bool FilterWindowList(screen_info *Screen);
void UpdateActiveWindowList(screen_info *Screen);
void ToggleFocusedWindowFloating(); // calls window->tree function
void MoveCursorToCenterOfWindow(window_info *Window);
void MoveCursorToCenterOfFocusedWindow();
bool FindClosestWindow(int Degrees, window_info *Target, bool Wrap);
void ClearMarkedWindow();
void MarkWindowContainer(window_info *Window);
void MarkFocusedWindowContainer();
void SetWindowRefFocus(AXUIElementRef WindowRef, window_info *Window, bool Notification);
void SetWindowFocus(window_info *Window);
// Does tree function
bool IsWindowNonResizable(AXUIElementRef WindowRef, window_info *Window, CFTypeRef NewWindowPos, CFTypeRef NewWindowSize);
void GetWindowInfo(const void *Key, const void *Value, void *Context);
bool GetWindowRole(window_info *Window, CFTypeRef *Role, CFTypeRef *SubRole);
bool GetWindowRef(window_info *Window, AXUIElementRef *WindowRef);
bool GetWindowRefFromCache(window_info *Window, AXUIElementRef *WindowRef);
void FreeWindowRefCache(int PID);

/* window (window-level) */
void MoveFloatingWindow(int X, int Y);
void CenterWindow(screen_info *Screen, window_info *Window);
bool WindowsAreEqual(window_info *Window, window_info *Match);
double GetWindowDistance(window_info *A, window_info *B);
void GetCenterOfWindow(window_info *Window, int *X, int *Y);
bool WindowIsInDirection(window_info *A, window_info *B, int Degrees, bool Wrap);
void CenterWindowInsideNodeContainer(AXUIElementRef WindowRef, int *Xptr, int *Yptr, int *Wptr, int *Hptr);
void SetWindowDimensions(AXUIElementRef WindowRef, window_info *Window, int X, int Y, int Width, int Height);
void ResizeWindowToContainerSize(tree_node *Node);
void ResizeWindowToContainerSize(window_info *Window);
void ResizeWindowToContainerSize();

/* tree */
void FocusFirstLeafNode();
void FocusLastLeafNode();
void UpdateWindowTree();
void CreateWindowNodeTree(screen_info *Screen, std::vector<window_info*> *Windows);
void ShouldWindowNodeTreeUpdate(screen_info *Screen);
void AddWindowToTreeOfUnfocusedMonitor(screen_info *Screen, window_info *Window);
void ShouldBSPTreeUpdate(screen_info *Screen, space_info *Space);
void AddWindowToBSPTree(screen_info *Screen, int WindowID);
void AddWindowToBSPTree();
void RemoveWindowFromBSPTree(screen_info *Screen, int WindowID, bool Refresh);
void RemoveWindowFromBSPTree();
void ShouldMonocleTreeUpdate(screen_info *Screen, space_info *Space);
void AddWindowToMonocleTree(screen_info *Screen, int WindowID);
void RemoveWindowFromMonocleTree(screen_info *Screen, int WindowID);
void ToggleWindowFloating(int WindowID);
void ToggleFocusedWindowParent();
void ToggleFocusedWindowFullscreen();
void DetachAndReinsertWindow(int WindowID, int Degrees);
void SwapFocusedWindowWithMarked();
void SwapFocusedWindowDirected(int Degrees);
void SwapFocusedWindowWithNearest(int Shift);
void FocusWindowByID(int WindowID);
void ShiftWindowFocus(int Shift);
void ShiftWindowFocusDirected(int Degrees);
void SetWindowFocusByNode(tree_node *Node);
void ModifySubtreeSplitRatioFromWindow(const double &Offset);
